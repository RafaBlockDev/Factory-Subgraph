interface MarketItems {
  id: ID!
  marketItemId: BigInt!
  nftContractAddress: Bytes!
  block: BigInt! # Timestamp in UNIX
}

# Scheam to split categories

type NFTCategory @entity {
  id: ID!
  name: String!
  nft: SingleNFT
  subCategory: String!
  description: String!
  price: BigInt!
  tokenURI: String!
}

# Schema for Digital NFT Product in Market

type SingleNFT @entity {
  id: ID!
  categoryId: String!
  category: String!
  tokenId: BigInt! # uint256  
  tokenURI: String! # string
  image: String!
  name: String!
  description: String!
  owner: Bytes! # Address in Hex
  creator: Bytes!
  price: BigInt!
  currency: String!
  royaltyPercentage: BigInt!
  quantity: BigInt! 
  totalSales: BigInt!
  totalRevenue: BigInt!
  subCategory: String!
  isActive: Boolean! # Boolean
  soldOut: Boolean!
  comments: String!
  tags: String!
  ratings: String!
  block: BigInt! # Block number
  timestamp: BigInt! # Timestamp in UNIX
  logIndex: BigInt!
  nftCategories: [NFTCategory!]! @derivedFrom(field: "nft")
}

# Schema for Services NFT

type ServiceNFT @entity {
  id: ID!
  categoryId: String!
  category: String!
  owner: Bytes! # address
  creator: Bytes!
  name: String! # string
  description: String!
  subCategory: String!
  price: BigInt! # uint256
  currency: String!
  tokenURI: String!
  image: String!
  tokenId: BigInt!
  quantity: BigInt!
  totalSales: BigInt!
  royaltyPercentage: BigInt!
  totalRevenue: BigInt!
  isActive: Boolean!
  soldOut: Boolean!
  comments: String!
  ratings: String!
  tags: String!
  block: BigInt! # Block number
  timestamp: BigInt! # Timestamp in UNIX
  logIndex: BigInt!
  }

# Schema for Subscription NFT
type SubscriptionNFT @entity {
  id: ID!
  categoryId: String!
  category: String!
  tokenId: BigInt!
  tokenURI: String!
  image: String
  name: String! # string
  description: String!
  owner: Bytes! # address
  creator: Bytes!
  price: BigInt! # uint256
  currency: String!
  royaltyPercentage: BigInt!
  quantity: BigInt!
  totalSales: BigInt!
  totalRevenue: BigInt!
  subCategory: String!
  isActive: Boolean! # Know if the product is in sale
  soldOut: Boolean!
  comments: String!
  ratings: String!
  tags: String!
  data: String!
  block: BigInt! # Block number
  timestamp: BigInt! # Timestamp in UNIX
  logIndex: BigInt!
  }

type CollectionCreated @entity {
  id: ID!
  categoryId: String!
  category: String!
  name: String!
  description: String!
  owner: Bytes!
  creator: Bytes!
  tokenURI: String!
  price: BigInt!
  currency: String!
  totalSupply: BigInt!
  totalSales: BigInt!
  isActive: Boolean!
  soldOut: Boolean!
  subCategory: String!
  comments: String!
  ratings: String!
  tags: String!
  address: Bytes!
  block: BigInt!
  timestamp: BigInt!
  logIndex: BigInt!
}

type Item @entity {
  id: ID!
  collection: Bytes!
  tokenId: BigInt!
  timestamp: BigInt!
  logIndex: BigInt!
}

type Event @entity {
  id: ID!
  timestamp: BigInt!
  txhash: String!
  logIndex: BigInt!
  collection: Bytes!
  tokenId: BigInt!
  name: String!
  from: String!
  to: String!
  tokenAdr: String!
  price: BigInt!
}

type NftItemSold @entity {
  id: ID!
  tokenId: BigInt!
  seller: Bytes!
  buyer: Bytes!
  price: BigInt!
  currency: String!
  timestamp: BigInt!
  logIndex: BigInt!
}

type ServiceRent @entity {
  id: ID!
  tokenId: BigInt!
  seller: Bytes!
  buyer: Bytes!
  price: BigInt!
  currency: String!
  timestamp: BigInt!
  logIndex: BigInt!
}

type SubscriptionPaidNFT @entity {
  id: ID!
  seller: Bytes!
  buyer: Bytes!
  price: BigInt!
  tokenId: BigInt!
  currency: String!
  timestamp: BigInt!
  logIndex: BigInt!
}

type FilterNFT @entity {
  id: ID!
  tokenId: BigInt!
  name: String!
  description: String!
  owner: Bytes!
  creator: Bytes!
  image: String!
  price: BigInt!
  currency: String!
  isActive: Boolean!
  totalSales: BigInt!
  totalRevenue: BigInt!
  royaltyPercentage: BigInt!
  tokenURI: String!
  comments: String!
  ratings: String!
  timestamp: BigInt!
  logIndex: BigInt!
}

type TxnNFT @entity {
  id: ID!
  seller: Bytes!
  buyer: Bytes!
  tokenId: BigInt!
  timestamp: BigInt!
}